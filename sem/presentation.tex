\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{wasysym}
\usepackage{float}
\usetikzlibrary{positioning,shapes,shadows,arrows,chains}
\usepackage{mathtools,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{minted}
\usetheme{Singapore}
\setbeamertemplate{footline}
{%
    \begin{beamercolorbox}{author in head/foot}
        \insertshortauthor \hfill \insertsubtitle \hfill \insertframenumber / \inserttotalframenumber
    \end{beamercolorbox}%
}
\setbeamertemplate{navigation symbols}{} % remove navigation symbols

\tikzset{%
	cell/.style={%
		rectangle split,
		rectangle split parts=4,
		rectangle split horizontal,
		rectangle split part fill={lightgray!30},
		rectangle split empty part width=0.1cm,
		draw
	}
}

\begin{document}

\title{Alignment in C}
\subtitle{Seminar ``Effiziente Programmierung in C''}
\date{2014-01-09}
\author{Sven-Hendrik Haase}
\institute{Universität Hamburg, Fakultät für Informatik}

\begin{frame}
    \titlepage
\end{frame}
%It's basically like Tetris but with computer memory

\begin{frame}{Outline}
    \tableofcontents
\end{frame}

\section{Introduction}
\subsection{Guiding questions of this presentation}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item What is data alignment?\pause
        \item How does it work in C?\pause
        \item Do we need to care?
	\end{itemize}
\end{frame}

\subsection{Memory addressing}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Computers address memory in word-sized chunks
		\item A \textbf{word} is a computer's natural unit for data
		\item Word size is defined by architecture
		\item Usual word sizes: 4 byte on 32-bit, 8 byte on 64-bit
		\item This means we can only address data at memory locations that are
			  multiples of 4 or 8 respectively (strictly speaking)
        \item Many processors allow access of arbitrary memory locations while some fail
            horribly
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
	\begin{itemize}
        \item Modern processors can load word-sized (4 byte) and long word-sized (8 byte) memory
            locations equally well
        \item Find out word-sizes:
        \begin{itemize}
            \item \verb|getconf WORD_BIT| (32 for me)
            \item \verb|getconf LONG_BIT| (64 for me)
        \end{itemize}
		\item Graphical example for 4 byte words:
	\end{itemize}

	\begin{center}
		\begin{tikzpicture}[start chain, level distance=0.5cm, node distance=0.1cm, every on chain/.style={draw, fill=lightgray, minimum width=2cm}]
			\node [on chain] {0x00000000} child {node [cell] {}};
			\node [on chain] {0x00000004} child {node [cell] {}};
			\node [on chain] {0x00000008} child {node [cell] {}};
			\node [on chain] {0x00000012} child {node [cell] {}};
		\end{tikzpicture}
	\end{center}
\end{frame}

\subsection{Alignment 101}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Assume a 32-bit architecture with a word size of 4 byte
		\item Let's save a 4 byte \textbf{int}
			\tikz[baseline=-0.5ex]{%
                \node[cell, rectangle split part fill={green!50},] {};} in our
            memory: \pause
	\end{itemize}
	\begin{center}
		\begin{tikzpicture}[start chain, level distance=0.5cm, node distance=0.1cm, every on chain/.style={draw, fill=lightgray, minimum width=2cm}]
			\node [on chain] {0x00000000} child {node [cell, rectangle split part fill={green!50},] {}};
			\node [on chain] {0x00000004} child {node [cell] {}};
			\node [on chain] {0x00000008} child {node [cell] {}};
			\node [on chain] {0x00000012} child {node [cell] {}};
		\end{tikzpicture}
	\begin{itemize}
		\item Looks good!
	\end{itemize}
	\end{center}
\end{frame}

\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Let's save a \textbf{char}
			\tikz[baseline=-0.5ex]{%
                \node[cell, rectangle split part fill={red!50,lightgray!30}] {};}, a \textbf{short}
			\tikz[baseline=-0.5ex]{%
                \node[cell, rectangle split part fill={blue!50,blue!50,lightgray!30}] {};} and an \textbf{int}
			\tikz[baseline=-0.5ex]{%
                \node[cell, rectangle split part fill={green!50},] {};} in our memory: \pause
	\end{itemize}
	\begin{center}
		\begin{tikzpicture}[start chain, level distance=0.5cm, node distance=0.1cm, every on chain/.style={draw, fill=lightgray, minimum width=2cm}]
			\node [on chain] {0x00000000} child {node [cell, rectangle split part fill={red!50,blue!50,blue!50,green!50}] {}};
			\node [on chain] {0x00000004} child {node [cell, rectangle split part fill={green!50,green!50,green!50,lightgray!30}] {}};
			\node [on chain] {0x00000008} child {node [cell] {}};
			\node [on chain] {0x00000012} child {node [cell] {}};
		\end{tikzpicture}
	\begin{itemize}
		\item Oh wait \pause
		\item Needs two memory accesses and some arithmetic to fetch the \textbf{int}.
	\end{itemize}
	\end{center}
\end{frame}

\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item We need to be smarter about this!
		\item Padding \tikz[baseline=-0.5ex]{%
                        \node[cell, rectangle split part fill={darkgray,lightgray!30},] {};} to the rescue\pause
	\end{itemize}
	\begin{center}
		\begin{tikzpicture}[start chain, level distance=0.5cm, node distance=0.1cm, every on chain/.style={draw, fill=lightgray, minimum width=2cm}]
			\node [on chain] {0x00000000} child {node [cell, rectangle split part fill={red!50,darkgray,blue!50,blue!50}] {}};
			\node [on chain] {0x00000004} child {node [cell, rectangle split part fill={green!50}] {}};
			\node [on chain] {0x00000008} child {node [cell] {}};
			\node [on chain] {0x00000012} child {node [cell] {}};
		\end{tikzpicture}
	\end{center}
    \begin{itemize}
        \item Much better
        \item This is considered \textbf{naturally aligned}
    \end{itemize}
\end{frame}

\subsection{Consquences of misalignment}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Different behavior depending on architecture
		\item Alignment fault errors on some platforms
		\item Bad performance on others
		\item SSE requires proper alignment per specification (though this restriction is about to be removed)
	\end{itemize}
\end{frame}

\section{Data Structure Alignment}
\subsection{Structs and stuff}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    Consider this:
    \begin{minted}{c}
    struct Foo {%
        char x; // 1 byte
        short y // 2 bytes
        int z; // 4 bytes
    };
    \end{minted}
    \begin{itemize}
        \item The struct's naive size would be 1 byte + 2 bytes + 4 bytes = 7 bytes\pause
        \item Of course, we know it's actually going to be 8 bytes due to padding
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item A struct is aligned to the largest type's alignment requirements
        \item This can yield some rather inefficient structures:
    \end{itemize}
    \begin{minted}{c}
    struct Foo {%
        char x; // 1 byte
        double y // 8 bytes
        char z; // 1 bytes
    };
    \end{minted}
    \begin{itemize}
        \item The struct's naive size would be 1 byte + 8 bytes + 1 bytes = 10 bytes\pause
        \item Its effective size is 24 byte!
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item The memory ineffiency can be minimized by reordering the members like so:
    \end{itemize}
    \begin{minted}{c}
    struct Foo {%
        char x; // 1 byte
        char z; // 1 bytes
        double y // 8 bytes
    };
    \end{minted}
    \begin{itemize}
        \item Now it's only 16 bytes, best we can do if we want to keep alignment
    \end{itemize}
\end{frame}

\subsection{Padding in the real world}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item Every decent compiler will automatically use data structure padding depending
            on architecture
        \item Some compilers support \verb|-Wpadded| which generates nice warnings about structure
            padding
        \item Example output with clang:
    \end{itemize}
    \begin{verbatim}
        clang -Wpadded -o example1 example1.c
        example1.c:5:11: warning: padding struct 
        'struct Foo' with 1 byte to align 'y' [-Wpadded]
        short y;
              ^
        1 warning generated.
    \end{verbatim}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item It's possible to prevent the compiler from padding a struct using either
            \verb|__attribute__((packed))| after a struct definition, \verb|#pragma pack (1)| in
            front of a struct definition or \verb|-fpack-struct| as a compiler parameter
        \item Either of these generate an incompatible ABI
        \item We can use the \verb|sizeof| operator to check the effective size of a struct
    \end{itemize}
\end{frame}

\subsection{Performance implications}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
        \item Do we actually have to worry about this?\pause
        \item Most likely not unless in special use cases (device drivers, extremely memory
            limited computers) or when using a compiler from 1878
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    For fun, let's look at the performance impact of misaligned memory:
    \begin{columns}[t]
        \column{.5\textwidth}
            \begin{minted}[fontsize=\tiny]{c}
struct Foo {%
    char x;
    short y;
    int z;
};

struct Foo foo;
clock_gettime(CLOCK, &start);
for (unsigned long i = 0; i < RUNS; ++i)
{%
     foo.z = 1;
     foo.z += 1;
}
clock_gettime(CLOCK, &end);
            \end{minted}

        \column{.5\textwidth}
            \begin{minted}[fontsize=\tiny]{c}
struct Bar {%
    char x;
    short y;
    int z;
} __attribute__((packed));

struct Bar bar;
clock_gettime(CLOCK, &start);
for (unsigned long i = 0; i < RUNS; ++i)
{%
     bar.z = 1;
     bar.z += 1;
}
clock_gettime(CLOCK, &end);
            \end{minted}
    \end{columns}
    Compiled with \small\verb|gcc -DRUNS=400000000 -DCLOCK=CLOCK_MONOTONIC -std=gnu99 -O0|
\end{frame}

\begin{frame}{\insertsection}{\insertsubsection}
    \begin{block}{Results}
        aligned runtime: 9.504220399 s\\
        unaligned runtime: 9.491816620 s
    \end{block}
    \pause
    \begin{itemize}
        \item Takes the same time!
	    \item Nowadays it totally doesn't matter for performance! :D
        \item Modern processors can read aligned/unaligned memory equally fast\pause
        \item But what about processors with the computing power of a potato?
	\end{itemize}
\end{frame}

\begin{frame}{\insertsection}{\insertsubsection}
    \begin{block}{Results on Raspberry Pi with 1/10 the loop length}
        aligned runtime: 12.174631568 s\\
        unaligned runtime: 26.453561832 s
    \end{block}
    \begin{itemize}
        \item On some architectures alignment matters a lot!
        \item We can nicely see that it takes about twice the time (two memory fetches) + some
            arithmetic
	\end{itemize}
\end{frame}

\subsection{SSE}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item Classically, SSE requires 16 byte alignment of data
        \item Requirement will be lifted soon
        \item Compilers automatically align to that when using \verb|__m128| types
        \item Very modern compilers even automagically vectorize loops
        \item No worries to the programmer {\large\smiley}
    \end{itemize}
\end{frame}

\section{Stack Alignment}
\subsection{Introduction}
\begin{frame}{\insertsection}{\insertsubsection}
	Even More Stuff
\end{frame}

\subsection{Stack Realignment}
\begin{frame}{\insertsection}{\insertsubsection}
	Even More Stuff
\end{frame}

\section{Summary}
\subsection{Things to worry about}
\begin{frame}{\insertsection}{\insertsubsection}
    \textbf{Do} worry about:
	\begin{itemize}
	    \item Positions of members within a struct
        \item Using weird compiler parameters
        \item GCC, Windows and SSE instructions
	\end{itemize}
\end{frame}

\subsection{Things not to worry about}
\begin{frame}{\insertsection}{\insertsubsection}
    \textbf{Do not} worry about:
	\begin{itemize}
	    \item Struct alignment/padding (compilers are smart)
	    \item Performance issues (computers are fast)
	\end{itemize}
\end{frame}

\begin{frame}{Resources}
	\begin{itemize}
        \tiny
        \item \url{http://www.agner.org/optimize/blog/read.php?i=142&v=t}
        \item \url{http://en.wikipedia.org/wiki/Data_structure_alignment}
        \item \url{http://en.wikipedia.org/wiki/Word_(data_type)}
        \item \url{http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/}
        \item \url{http://lemire.me/blog/archives/2012/05/31/data-alignment-for-speed-myth-or-reality/}
        \item \url{http://www.makelinux.com/books/lkd2/ch19lev1sec3}
        \item \url{http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/aligned.html}
        \item \url{http://tuxsudh.blogspot.de/2005/05/structure-packing-in-gcc.html}
        \item \url{http://www.peterstock.co.uk/games/mingw_sse/}
	\end{itemize}
\end{frame}

\end{document}
