\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{wasysym}
\usepackage{float}
\usetikzlibrary{positioning,shapes,shadows,arrows,chains}
\usepackage{mathtools,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{minted}
\usetheme{Singapore}
\setbeamertemplate{footline}
{%
    \begin{beamercolorbox}{author in head/foot}
        \insertshortauthor \hfill \insertsubtitle \hfill \insertframenumber / \inserttotalframenumber
    \end{beamercolorbox}%
}
\setbeamertemplate{navigation symbols}{} % remove navigation symbols

\tikzset{%
	cell/.style={%
		rectangle split,
		rectangle split parts=4,
		rectangle split horizontal,
		rectangle split part fill={lightgray!30},
		rectangle split empty part width=0.1cm,
		draw
	}
}

\begin{document}

\title{Alignment in C}
\subtitle{Seminar ``Effiziente Programmierung in C''}
\date{2014-01-09}
\author{Sven-Hendrik Haase}
\institute{Universität Hamburg, Fakultät für Informatik}

\begin{frame}
    \titlepage
\end{frame}
%It's basically like Tetris but with computer memory

\begin{frame}{Outline}
    \tiny
    \tableofcontents
\end{frame}

\section{Introduction}
\subsection{Guiding questions of this presentation}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Which types of alignment exist in C?\pause
		\item What is data alignment?\pause
		\item What is heap alignment?\pause
		\item What is stack alignment?\pause
        \item How does it work in C?\pause
        \item Do we need to care abouy any of these?
	\end{itemize}
\end{frame}

\subsection{Memory addressing}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Computers address memory in word-sized chunks\pause
		\item A \textbf{word} is a computer's natural unit for data
		\item Word size is defined by architecture
		\item Usual word sizes: 4 byte on 32-bit, 8 byte on 64-bit\pause
		\item This means we can only address data at memory locations that are
			  multiples of 4 or 8 respectively (strictly speaking)
        \item Many processors allow access of arbitrary memory locations while some fail
            horribly
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
	\begin{itemize}
        \item Modern processors can load word-sized (4 byte) and long word-sized (8 byte) memory
            locations equally well
        \item Find out word-sizes:
        \begin{itemize}
            \item \verb|getconf WORD_BIT| (32 for me, 32 on RPi)
            \item \verb|getconf LONG_BIT| (64 for me, 32 on RPi)
        \end{itemize}
	\end{itemize}
\end{frame}

\subsection{Alignment 101}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Assume a 32-bit architecture with a word size of 4 byte
            \begin{center}
                \begin{tikzpicture}[start chain, level distance=0.5cm, node distance=0.1cm, every on chain/.style={draw, fill=lightgray, minimum width=2cm}]
                    \node [on chain] {0x00000000} child {node [cell] {}};
                    \node [on chain] {0x00000004} child {node [cell] {}};
                    \node [on chain] {0x00000008} child {node [cell] {}};
                    \node [on chain] {0x00000012} child {node [cell] {}};
                \end{tikzpicture}
            \end{center} \pause
		\item Let's save a 4 byte \textbf{int}
			\tikz[baseline=-0.5ex]{%
                \node[cell, rectangle split part fill={green!50},] {};} in our
            memory: \pause
	\end{itemize}
	\begin{center}
		\begin{tikzpicture}[start chain, level distance=0.5cm, node distance=0.1cm, every on chain/.style={draw, fill=lightgray, minimum width=2cm}]
			\node [on chain] {0x00000000} child {node [cell, rectangle split part fill={green!50},] {}};
			\node [on chain] {0x00000004} child {node [cell] {}};
			\node [on chain] {0x00000008} child {node [cell] {}};
			\node [on chain] {0x00000012} child {node [cell] {}};
		\end{tikzpicture}
	\begin{itemize}
		\item Looks good!
	\end{itemize}
	\end{center}
\end{frame}

\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Let's save a \textbf{char}
			\tikz[baseline=-0.5ex]{%
                \node[cell, rectangle split part fill={red!50,lightgray!30}] {};}, a \textbf{short}
			\tikz[baseline=-0.5ex]{%
                \node[cell, rectangle split part fill={blue!50,blue!50,lightgray!30}] {};} and an \textbf{int}
			\tikz[baseline=-0.5ex]{%
                \node[cell, rectangle split part fill={green!50},] {};} in our memory: \pause
	\end{itemize}
	\begin{center}
		\begin{tikzpicture}[start chain, level distance=0.5cm, node distance=0.1cm, every on chain/.style={draw, fill=lightgray, minimum width=2cm}]
			\node [on chain] {0x00000000} child {node [cell, rectangle split part fill={red!50,blue!50,blue!50,green!50}] {}};
			\node [on chain] {0x00000004} child {node [cell, rectangle split part fill={green!50,green!50,green!50,lightgray!30}] {}};
			\node [on chain] {0x00000008} child {node [cell] {}};
			\node [on chain] {0x00000012} child {node [cell] {}};
		\end{tikzpicture}
	\begin{itemize} \pause
		\item Oh wait \pause
		\item Needs two memory accesses and some arithmetic to fetch the \textbf{int}.
	\end{itemize}
	\end{center}
\end{frame}

\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item We need to be smarter about this!
		\item Padding \tikz[baseline=-0.5ex]{%
                        \node[cell, rectangle split part fill={darkgray,lightgray!30},] {};} to the rescue\pause
	\end{itemize}
	\begin{center}
		\begin{tikzpicture}[start chain, level distance=0.5cm, node distance=0.1cm, every on chain/.style={draw, fill=lightgray, minimum width=2cm}]
			\node [on chain] {0x00000000} child {node [cell, rectangle split part fill={red!50,darkgray,blue!50,blue!50}] {}};
			\node [on chain] {0x00000004} child {node [cell, rectangle split part fill={green!50}] {}};
			\node [on chain] {0x00000008} child {node [cell] {}};
			\node [on chain] {0x00000012} child {node [cell] {}};
		\end{tikzpicture}
	\end{center}
    \begin{itemize}
        \item Much better
        \item This is considered \textbf{naturally aligned}
    \end{itemize}
\end{frame}

\subsection{Consquences of misalignment}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Different behavior depending on architecture
		\item Alignment fault errors on some platforms (RISC, ARM)
		\item Bad performance on others
		\item SSE requires proper alignment per specification (though this restriction is about to be removed)
	\end{itemize}
\end{frame}

\subsection{Different Types of Alignment}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
		\item Some definitions so we don't get confused:\pause
        \item \textbf{Data Structure Alignment} refers to the alignment of sequential memory inside
            a data structure (struct) \pause
        \item \textbf{Heap Alignment} refers to the alignment of dynamically allocated memory\pause
        \item \textbf{Stack Alignment} refers to the alignment of the stack pointer
	\end{itemize}
\end{frame}

\section{Data Structure Alignment}
\subsection{Structs and stuff}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \pause
    Consider this:
    \begin{minted}{c}
    struct Foo {
        char x; // 1 byte
        short y // 2 bytes
        int z; // 4 bytes
    };
    \end{minted}
    \begin{itemize}
        \item The struct's naive size would be 1 byte + 2 bytes + 4 bytes = 7 bytes\pause
        \item Of course, we know it's actually going to be \pause 8 bytes due to padding
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item \textbf{A struct is aligned to the largest type's alignment requirements}\pause
        \item This can yield some rather inefficient structures:
    \end{itemize}
    \begin{minted}{c}
    struct Foo {
        char x; // 1 byte
        double y // 8 bytes
        char z; // 1 bytes
    };
    \end{minted}
    \begin{itemize}
        \item The struct's naive size would be 1 byte + 8 bytes + 1 bytes = 10 bytes\pause
        \item Its effective size is \pause 24 bytes!
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item The memory ineffiency can be minimized by reordering the members like so:
    \end{itemize}
    \begin{minted}{c}
    struct Foo {
        char x; // 1 byte
        char z; // 1 bytes
        double y // 8 bytes
    };
    \end{minted}
    \begin{itemize}
        \item Now it's only 16 bytes, best we can do if we want to keep alignment
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item How about this?
    \end{itemize}
    \begin{minted}{c}
    struct Foo {
        double a; // 8 byte
        char b; // 1 byte
        char c; // 1 byte
        short d; // 2 bytes
        int e; // 4 bytes
        double f; // 8 bytes
    };
    \end{minted}
    \pause
    \begin{itemize}
        \item This structure is 24 bytes in total
        \item Most efficient configuration possible
        \item It's called \textbf{tighly packed}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item How about extension types?
    \end{itemize}
    \begin{minted}{c}
    struct Foo {
        char x; // 1 byte
        __uint128_t y; // 16 bytes
        char a; // 1 byte
        __uint128_t b; // 16 bytes
    };
    \end{minted}
    \begin{itemize}
        \item This struct is \pause 64 bytes
        \item World's most wasteful struct
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item Of course, we can also reorder this to make it 34 bytes only
    \end{itemize}
    \begin{minted}{c}
    struct Foo {
        __uint128_t y; // 16 bytes
        __uint128_t b; // 16 bytes
        char x; // 1 byte
        char a; // 1 byte
    };
    \end{minted}
\end{frame}

\subsection{Padding in the real world}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item Every decent compiler will automatically use data structure padding depending
            on architecture\pause
        \item Some compilers support \verb|-Wpadded| which generates nice warnings about structure
            padding\pause
        \item Compiler warnings can help you find inefficiencies
        \item Example output with clang:
    \end{itemize}
    \begin{verbatim}
        clang -Wpadded -o example1 example1.c
        example1.c:5:11: warning: padding struct 
        'struct Foo' with 1 byte to align 'y' [-Wpadded]
        short y;
              ^
        1 warning generated.
    \end{verbatim}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item It's possible to prevent the compiler from padding a struct using either
            \verb|__attribute__((packed))| after a struct definition, \verb|#pragma pack (1)| in
            front of a struct definition or \verb|-fpack-struct| as a compiler parameter\pause
        \item Either of these generate an incompatible ABI
        \item We can use the \verb|sizeof| operator to check the effective size of a struct
    \end{itemize}
\end{frame}

\subsection{Performance implications}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
        \item Do we actually have to worry about this?\pause
        \item Most likely not unless in special use cases (device drivers, extremely memory
            limited computers) or when using a compiler from 1878
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    For fun, let's look at the performance impact of misaligned memory:
    \begin{columns}[]
        \column{.5\textwidth}
            \begin{minted}[fontsize=\tiny]{c}
    struct Foo {
        char x;
        short y;
        int z;
    };

    struct Foo foo;
    clock_gettime(CLOCK, &start);
    for (unsigned long i = 0; i < RUNS; ++i) {
         foo.z = 1;
         foo.z += 1;
    }
    clock_gettime(CLOCK, &end);
            \end{minted}

        \column{.5\textwidth}
            \begin{minted}[fontsize=\tiny]{c}
    struct Bar {
        char x;
        short y;
        int z;
    } __attribute__((packed));

    struct Bar bar;
    clock_gettime(CLOCK, &start);
    for (unsigned long i = 0; i < RUNS; ++i) {
         bar.z = 1;
         bar.z += 1;
    }
    clock_gettime(CLOCK, &end);
            \end{minted}
    \end{columns}
    \begin{block}{Compiled with}
        \small \verb|gcc -DRUNS=400000000 -DCLOCK=CLOCK_MONOTONIC -std=gnu99 -O0|
    \end{block}
\end{frame}

\begin{frame}{\insertsection}{\insertsubsection}
    \begin{block}{Results}
        aligned runtime: 9.504220399 s\\
        unaligned runtime: 9.491816620 s
    \end{block}
    \pause
    \begin{itemize}
        \item Takes the same time!\pause
	    \item Nowadays it totally doesn't matter for performance! :D
        \item Modern processors can read aligned/unaligned memory equally fast (at least Intel
            Sandy Bridge and up)\pause
        \item But what about processors with the computing power of a potato?
	\end{itemize}
\end{frame}

\begin{frame}{\insertsection}{\insertsubsection}
    \begin{block}{Results on Raspberry Pi with 1/10 the loop length}
        aligned runtime: 12.174631568 s\\
        unaligned runtime: 26.453561832 s
    \end{block}
    \pause
    \begin{itemize}
        \item On some architectures alignment matters a lot!
        \item We can nicely see that it takes about twice the time (two memory fetches) + some
            arithmetic
	\end{itemize}
\end{frame}

\subsection{SSE}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item Classically, SSE requires 16 byte alignment of data and stack pointer
        \item Requirement will be lifted soon\pause
        \item Compilers automatically align to that when using SIMD types (\verb|__m128| and
            friends)
        \item x86\_64 is 16 byte aligned anyway
        \item Very modern compilers even automagically vectorize loops
        \item No worries to the programmer {\large\smiley}
    \end{itemize}
\end{frame}

\section{Heap Alignment}
\subsection{Introduction}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \pause
    \begin{itemize}
        \item \verb|malloc| is usually good enough
        \item Allocated memory is aligned to largest primitive type\pause
        \item Use \verb|aligned_alloc| instead of \verb|malloc| for custom alignments
        \item Other heap alignment functions: \verb|posix_memalign|, \verb|aligned_alloc| and \verb|valloc|\pause
        \item \verb|memalign| and \verb|pvalloc| are considered obsolete
    \end{itemize}
\end{frame}

\subsection{Example}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{minted}[fontsize=\tiny]{c}
#include <stdio.h>
#include <stdlib.h>

#define SIZE 1024 * 1024
#define ALIGN 4096
int main()
{
    void* a = malloc(SIZE);
    void* b = aligned_alloc(ALIGN, SIZE);
    
    printf("a: %p, a %% %i: %lu\n", a, ALIGN, ((unsigned long)a) % ALIGN);
    printf("b: %p, b %% %i: %lu\n", b, ALIGN, ((unsigned long)b) % ALIGN);
    return 0;
}
    \end{minted}
    \begin{block}{Results}
        a: 0x7fdec2265010, a \% 4096: 16\\
        b: 0x7fdec1cec000, b \% 4096: 0
    \end{block}
\end{frame}

\subsection{Use Cases}
\begin{frame}{\insertsection}{\insertsubsection}
    You should consider using custom heap memory alignments when\ldots\pause
    \begin{itemize}
        \item interfacing with low-level stuff (hardware)\pause
        \item trying to be really clever about CPU cache line optimization\pause
        \item writing custom allocators (for instance when writing an interpreter or garbage
            collector)\pause
        \item using SIMD and your compilers is too stupid to align stuff properly by itself
    \end{itemize}
\end{frame}

\section{Stack Alignment}
\subsection{Introduction}
\begin{frame}{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item Different platforms make different assumptions about stack alignment
        \item Platforms:
            \begin{itemize}
                \item Linux: depends (legacy is 4 byte, modern is 16 byte)
                \item Windows: 4 byte
                \item OSX: 16 byte
                \item x86\_64 always uses 16 byte
            \end{itemize}
            \pause
        \item But why do we care? \pause
        \item Mixing stack alignments is very bad!
    \end{itemize}
\end{frame}

\subsection{The Problem}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    Consider this:
    \begin{minted}{c}
    void foo() {
        struct MyType bar;
    }
    \end{minted}
    \begin{itemize}
        \item Looks benign!\pause
        \item Imagine it is 16 byte aligned, then what will happen if this is called from a
            platform with 4 byte alignment such as Windows?\pause
        \item \textbf{Stack corruption}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item We don't usually care about stack alignment unless we have to\pause
        \item If we have cross-architecture calls, we need special tricks\pause
        \item To fix, decorate function with \verb|__attribute__((force_align_arg_pointer))| or use
            \verb|-mstackrealign| \pause (or stop using Windows)
        \item Other compiler arguments to play with stack alignment:
            \verb|-mpreferred-stack-boundary|, \verb|-mincoming-stack-boundary|
    \end{itemize}
\end{frame}

\subsection{Use Cases}
\begin{frame}[fragile]{\insertsection}{\insertsubsection}
    \begin{itemize}
        \item Play with stack alignment only if you absolutely, positively have to\pause
        \item Software that needs stack alignment: valgrind (virtual CPU), wine (cross-compiled
            cross-platform cross-architecture compatibility layer), kernels\pause
        \item Very memory limited device\pause
        \item You will probably never have to worry about this
    \end{itemize}
\end{frame}

\section{Summary}
\subsection{TL;DR}
\begin{frame}{\insertsection}{\insertsubsection}
    \begin{block}{\textbf{Do} worry about}
        \begin{itemize}
            \item Positions of members within a struct
            \item Using weird compiler parameters
            \item GCC, Windows and SSE instructions
        \end{itemize}
    \end{block}
    \pause
    \begin{block}{\textbf{Do not} worry about}
        \begin{itemize}
            \item Struct alignment/padding (compilers are smart)
            \item Performance issues (computers are fast)
        \end{itemize}
    \end{block}
\end{frame}

\subsection{Resources}
\begin{frame}{\insertsection}{\insertsubsection}
	\begin{itemize}
        \tiny
        \item \url{http://www.agner.org/optimize/blog/read.php?i=142&v=t}
        \item \url{http://en.wikipedia.org/wiki/Data_structure_alignment}
        \item \url{http://en.wikipedia.org/wiki/Word_(data_type)}
        \item \url{http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/}
        \item \url{http://lemire.me/blog/archives/2012/05/31/data-alignment-for-speed-myth-or-reality/}
        \item \url{http://www.makelinux.com/books/lkd2/ch19lev1sec3}
        \item \url{http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/aligned.html}
        \item \url{http://tuxsudh.blogspot.de/2005/05/structure-packing-in-gcc.html}
        \item \url{http://www.peterstock.co.uk/games/mingw_sse/}
        \item \url{http://eigen.tuxfamily.org/dox-2.0/WrongStackAlignment.html}
	\end{itemize}
\end{frame}

\end{document}
